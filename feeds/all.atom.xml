<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yullin's Blog</title><link href="https://yull.in/" rel="alternate"></link><link href="https://yull.in/feeds/all.atom.xml" rel="self"></link><id>https://yull.in/</id><updated>2019-02-11T10:58:00+08:00</updated><entry><title>chrome 73 released 自动画中画 支持硬件媒体按钮</title><link href="https://yull.in/chrome-73-released.html" rel="alternate"></link><published>2019-02-11T10:58:00+08:00</published><updated>2019-02-11T10:58:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2019-02-11:/chrome-73-released.html</id><summary type="html">&lt;p&gt;桌面端Chrome浏览器在即将到来的版本更迭中有望获得一系列新的功能，我们从各种Commits、媒体发掘的实验性功能以及Canary通道都能一瞥这些新功能，包括可跟随系统的原生黑暗主题，高性能的“Never-Slow Mode”和标签预览等等。今天Chrome 73刚刚升级至Beta通道，预计在未来几周内会发布稳定版。Chrome 73中最值得注意的新功能包括支持硬件多媒体按钮，对PWA应用的自动画中画功能，以及画中画功能中跳过广告等等。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;支持硬件多媒体按钮&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;用户将能够通过键盘上的多媒体键控制 Chrome 中播放的音视频内容，指令包括跳过播放列表、播放、暂停、前一曲目、下一曲目、前后向滚动等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img" height="60%" src="https://oscimg.oschina.net/oscnet/79457c674363241c0ff32eb6617dfdc88c3.jpg" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;这是一种 Chrome 级别的按键支持，而不是标签级别，这意味着无论 Chrome 浏览器是在操作系统的前台还是最小化在后台，用户对多媒体键的操作都能生效。该多媒体键功能依赖于 Media Session API，开发人员可以使用它来控制浏览器中的媒体播放，还可以自定义多媒体键的交互。
&lt;img alt="多媒体交互" src="https://static.cnbetacdn.com/thumb/article/2019/0211/e14d9ddc8a4241b.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;可跟随系统的黑暗主题&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;现在开始跟随您的系统范围主题设置，这意味着如果您在Windows 10中选择Dark Theme，您的Chrome浏览器也会立即切换到Dark模式。这一变化是谷歌努力与Windows 10更紧密合作的最新举措，包括支持原生Windows 10通知功能，致力于Windows …&lt;/p&gt;</summary><content type="html">&lt;p&gt;桌面端Chrome浏览器在即将到来的版本更迭中有望获得一系列新的功能，我们从各种Commits、媒体发掘的实验性功能以及Canary通道都能一瞥这些新功能，包括可跟随系统的原生黑暗主题，高性能的“Never-Slow Mode”和标签预览等等。今天Chrome 73刚刚升级至Beta通道，预计在未来几周内会发布稳定版。Chrome 73中最值得注意的新功能包括支持硬件多媒体按钮，对PWA应用的自动画中画功能，以及画中画功能中跳过广告等等。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;支持硬件多媒体按钮&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;用户将能够通过键盘上的多媒体键控制 Chrome 中播放的音视频内容，指令包括跳过播放列表、播放、暂停、前一曲目、下一曲目、前后向滚动等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img" height="60%" src="https://oscimg.oschina.net/oscnet/79457c674363241c0ff32eb6617dfdc88c3.jpg" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;这是一种 Chrome 级别的按键支持，而不是标签级别，这意味着无论 Chrome 浏览器是在操作系统的前台还是最小化在后台，用户对多媒体键的操作都能生效。该多媒体键功能依赖于 Media Session API，开发人员可以使用它来控制浏览器中的媒体播放，还可以自定义多媒体键的交互。
&lt;img alt="多媒体交互" src="https://static.cnbetacdn.com/thumb/article/2019/0211/e14d9ddc8a4241b.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;可跟随系统的黑暗主题&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;现在开始跟随您的系统范围主题设置，这意味着如果您在Windows 10中选择Dark Theme，您的Chrome浏览器也会立即切换到Dark模式。这一变化是谷歌努力与Windows 10更紧密合作的最新举措，包括支持原生Windows 10通知功能，致力于Windows 10 for ARM的原生支持，当然还有为操作系统开发黑暗主题。
&lt;img alt="跟随系统黑暗主题" height="60%" src="https://static.cnbetacdn.com/article/2019/02/a0777d699c4afed.gif" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;而且在随后的更新中又修复了菜单弹出时文本颜色的错误。解决了深色背景上的黑色文本和浅色背景故障上的白色文本。菜单上的文本不再是黑色，您最终可以轻松阅读它们。同样，右键菜单也已更新，并修复了毛刺。另一个在页面中出现白色文本的错误已得到解决。此外，Google还更改了在Omnibox上选择URL时显示的颜色。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Chrome-shortcuts.jpg" src="https://static.cnbetacdn.com/article/2019/0208/4eb7732c7353de0.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Chrome-menu-1-663x420.jpg" src="https://static.cnbetacdn.com/article/2019/0208/09d5d8c1a82109b.jpg"&gt;&lt;/p&gt;
&lt;p&gt;从外观上看，Google Chrome的黑暗外观已经完成，很快就会发布给测试用户。根据Chromium的帖子提交的信息，谷歌也在努力修复图标对黑暗模式的兼容性。&lt;/p&gt;
&lt;p&gt;自动画中画功能&lt;/p&gt;
&lt;p&gt;自动画中画（Automatic Picture-in-Picture）适用于已经安装到系统上的PWA应用程序。Chrome 70版本中引入了在Windows 10平台安装PWA应用的功能，从网页应用的交互体验接近于原生应用，可以将其固定到开始菜单，并且通过Action Center来获得原生通知。不过在此前只有用户手动方式才能将视频切换至画中画模式。
&lt;img alt="自动画中画" src="https://static.cnbetacdn.com/article/2018/1221/51c2c6cb7e2ff66.png"&gt;&lt;/p&gt;
&lt;p&gt;启用自动画中画功能之后，应用中嵌入的视频元素可以自动激活，并且会根据用户焦点自动离开画中画状态。一个案例就是在视频会议应用中，当用户导航切换不同的网页应用或者在浏览器不同标签之后可以自动将视频切换至画中画模式。包括Teams在内的诸多PWA应用程序将会因此获益。&lt;/p&gt;
&lt;p&gt;除了自动画中画功能之外，还可以使用Chrome 73添加使用画中画行为跳过视频中广告的功能。在Chrome 73版本中，PWA应用程序可以在桌面上自动播放带声音的多媒体文件。&lt;/p&gt;
&lt;p&gt;Chrome 73 Beta版本下载：&lt;/p&gt;
&lt;p&gt;Windows x64版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;最新版本：73.0.3683.27

文件大小：52.93 MB

SHA1：F7A9CEBB55B53FE6DDCC8581D1E375CE29095D19

SHA256：9F0E229D28ED0F528A1BE15B8F0ECF41C6C92DB247F75A5486C7BFA9F9E31344

http://dl.google.com/release2/chrome/EyS63SxRtQ8_73.0.3683.27/73.0.3683.27_chrome_installer.exe

https://dl.google.com/release2/chrome/EyS63SxRtQ8_73.0.3683.27/73.0.3683.27_chrome_installer.exe

http://www.google.com/dl/release2/chrome/EyS63SxRtQ8_73.0.3683.27/73.0.3683.27_chrome_installer.exe

https://www.google.com/dl/release2/chrome/EyS63SxRtQ8_73.0.3683.27/73.0.3683.27_chrome_installer.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Windows 版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;最新版本：73.0.3683.27

文件大小：51.92 MB

SHA1：7987A6618279C64C25576A3A28256DBEFBE1D3F7

SHA256：CF1B334D666A21F75C182E60E51E08799A6DCF8282826064762D826F282709B5

http://dl.google.com/release2/chrome/AJKpXo5co64_73.0.3683.27/73.0.3683.27_chrome_installer.exe

https://dl.google.com/release2/chrome/AJKpXo5co64_73.0.3683.27/73.0.3683.27_chrome_installer.exe

http://www.google.com/dl/release2/chrome/AJKpXo5co64_73.0.3683.27/73.0.3683.27_chrome_installer.exe

https://www.google.com/dl/release2/chrome/AJKpXo5co64_73.0.3683.27/73.0.3683.27_chrome_installer.exe
&lt;/pre&gt;&lt;/div&gt;</content><category term="chrome"></category><category term="浏览器"></category><category term="新版本"></category><category term="beta"></category></entry><entry><title>输出重定向到文件的时效性</title><link href="https://yull.in/about-redirect-output.html" rel="alternate"></link><published>2019-01-14T12:00:00+08:00</published><updated>2019-01-14T12:00:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2019-01-14:/about-redirect-output.html</id><summary type="html">&lt;p&gt;在做一个监控脚本时，需要将结果输出到一个文件，然后另外一个脚本来读取该文件的内容作为结果进行判断。&lt;br&gt;
经过测试发现，shell中的命令行重定向功能有个特点，即在命令一开始执行时，就已开始创建了对应的文件，下面举个例子来进行说明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# test.py &amp;gt; /tmp/test.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这条命令中，假如该命令执行总共需要30秒，而在该命令一开始执行时，&lt;code&gt;/tmp/test.log&lt;/code&gt;就已创建，而不是等到命令执行完成再创建。而这时如果有执行频率较高，在30秒内去检查&lt;code&gt;/tmp/test.log&lt;/code&gt;文件内的内容的话，有可能是检查不到正确的内容的。&lt;br&gt;
所以我们在使用重定向功能时需要注意到这点，创建文件的时间是否就是你所设想的时间呢？&lt;/p&gt;</summary><content type="html">&lt;p&gt;在做一个监控脚本时，需要将结果输出到一个文件，然后另外一个脚本来读取该文件的内容作为结果进行判断。&lt;br&gt;
经过测试发现，shell中的命令行重定向功能有个特点，即在命令一开始执行时，就已开始创建了对应的文件，下面举个例子来进行说明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# test.py &amp;gt; /tmp/test.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这条命令中，假如该命令执行总共需要30秒，而在该命令一开始执行时，&lt;code&gt;/tmp/test.log&lt;/code&gt;就已创建，而不是等到命令执行完成再创建。而这时如果有执行频率较高，在30秒内去检查&lt;code&gt;/tmp/test.log&lt;/code&gt;文件内的内容的话，有可能是检查不到正确的内容的。&lt;br&gt;
所以我们在使用重定向功能时需要注意到这点，创建文件的时间是否就是你所设想的时间呢？&lt;/p&gt;</content><category term="shell"></category><category term="linux"></category><category term="file"></category></entry><entry><title>install php5.6 on centos6</title><link href="https://yull.in/install-php5.6-on-centos6.html" rel="alternate"></link><published>2019-01-09T11:48:00+08:00</published><updated>2019-01-09T11:48:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2019-01-09:/install-php5.6-on-centos6.html</id><summary type="html">&lt;p&gt;本次安装系统环境为Centos6 x86_64&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# cd /usr/local/src
# wget http://cn2.php.net/distributions/php-5.6.39.tar.gz
# tar xzf php-5.6.39.tar.xz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装依赖包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# yum install gcc gcc-c++ bison bison-devel zlib-devel libmcrypt-devel mcrypt mhash-devel openssl-devel libxml2-devel libcurl-devel bzip2-devel readline-devel libedit-devel sqlite-devel
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;开始编译安装（这里先别急着去执行，先往文章后面看看）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# ./configure \
--prefix=/usr/local/php …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本次安装系统环境为Centos6 x86_64&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# cd /usr/local/src
# wget http://cn2.php.net/distributions/php-5.6.39.tar.gz
# tar xzf php-5.6.39.tar.xz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装依赖包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# yum install gcc gcc-c++ bison bison-devel zlib-devel libmcrypt-devel mcrypt mhash-devel openssl-devel libxml2-devel libcurl-devel bzip2-devel readline-devel libedit-devel sqlite-devel
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;开始编译安装（这里先别急着去执行，先往文章后面看看）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# ./configure \
--prefix=/usr/local/php \
--with-config-file-path=/usr/local/php/etc \
--enable-inline-optimization \
--disable-debug \
--disable-rpath \
--enable-shared \
--enable-opcache \
--enable-fpm \
--with-fpm-user=www \
--with-fpm-group=www \
--with-mysql=mysqlnd \
--with-mysqli=mysqlnd \
--with-pdo-mysql=mysqlnd \
--with-gettext \
--enable-mbstring \
--with-iconv=/usr/local/libiconv \
--with-mcrypt \
--with-mhash \
--with-openssl \
--enable-bcmath \
--enable-soap \
--with-libxml-dir \
--enable-pcntl \
--enable-shmop \
--enable-sysvmsg \
--enable-sysvsem \
--enable-sysvshm \
--enable-sockets \
--with-curl \
--with-zlib \
--enable-zip \
--with-bz2 \
--with-readline \
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译时报错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Please&lt;/span&gt; &lt;span class="n"&gt;reinstall&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;iconv&lt;/span&gt; &lt;span class="n"&gt;library&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装iconv lib&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# cd /usr/local/src/
# wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.15.tar.gz
# tar xzf libiconv-1.15.tar.gz
# cd libiconv-1.15
# ./configure
# make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;继续编译，又报错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Don&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;know&lt;/span&gt; &lt;span class="n"&gt;how&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;flock&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;set&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;opcache&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在我加上&lt;code&gt;–-enable-opcache=no&lt;/code&gt;之后，又报错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;off_t&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt; &lt;span class="n"&gt;your&lt;/span&gt; &lt;span class="n"&gt;library&lt;/span&gt; &lt;span class="n"&gt;configuration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到这里，我的内心OS “WTF”&lt;br&gt;
找GOOGLE老师咨询了一下，原来是要这样处理一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# echo &amp;#39;/usr/local/lib64
/usr/local/lib
/usr/lib
/usr/lib64&amp;#39;&amp;gt;&amp;gt;/etc/ld.so.conf 
# ldconfig -v
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;据说这样处理之后，即便不改之前的opcache设置也正常，不过我没试，你有空倒是可以&lt;code&gt;--enable-opcache&lt;/code&gt;再测试一次。&lt;br&gt;
修改之后是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# cat /etc/ld.so.conf
include ld.so.conf.d/*.conf
/usr/local/lib
/usr/lib
/usr/lib64
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后就可以一路畅快的完成configure了，你如果仔细去关注那飞快滚动的屏幕的话，会发现不少Warning，啊注意不是“FBI WARNING”，不过我都是略过了。
再接下来就是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后就是，嗯。。。收工。&lt;/p&gt;</content><category term="php"></category><category term="centos6"></category><category term="php extension"></category></entry><entry><title>Nginx反向代理配置</title><link href="https://yull.in/nginx-reverse-proxy-pass.html" rel="alternate"></link><published>2018-12-19T16:05:00+08:00</published><updated>2018-12-19T16:05:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-12-19:/nginx-reverse-proxy-pass.html</id><summary type="html">&lt;p&gt;这里主要记录Nginx服务器的反向代理proxy_pass配置方法中容易踩坑的地方,就是经常被提到的url的/问题的相关说明,需要的朋友可以参考下&lt;/p&gt;
&lt;h2&gt;普通反向代理&lt;/h2&gt;
&lt;p&gt;Nginx的普通的反向代理配置还是比较简单的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者可以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要配置一个相对复杂的反向代理,比如，将url中以/test/开头的请求转发到后台对应的某台server上&lt;br&gt;
可以在Nginx里设置一个变量，来临时保存/test/后面的路径信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;^~&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;($request_uri&lt;/span&gt; &lt;span class="err"&gt;~&lt;/span&gt; &lt;span class="err"&gt;/test/(\d+)/(.+))&lt;/span&gt;
    &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;set&lt;/span&gt; &lt;span class="err"&gt;$id&lt;/span&gt; &lt;span class="err"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;set&lt;/span&gt; &lt;span class="err"&gt;$params&lt;/span&gt; &lt;span class="err"&gt;$2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;proxy_pass&lt;/span&gt; &lt;span class="nt"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="nt"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;domain …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;这里主要记录Nginx服务器的反向代理proxy_pass配置方法中容易踩坑的地方,就是经常被提到的url的/问题的相关说明,需要的朋友可以参考下&lt;/p&gt;
&lt;h2&gt;普通反向代理&lt;/h2&gt;
&lt;p&gt;Nginx的普通的反向代理配置还是比较简单的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者可以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要配置一个相对复杂的反向代理,比如，将url中以/test/开头的请求转发到后台对应的某台server上&lt;br&gt;
可以在Nginx里设置一个变量，来临时保存/test/后面的路径信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;^~&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;($request_uri&lt;/span&gt; &lt;span class="err"&gt;~&lt;/span&gt; &lt;span class="err"&gt;/test/(\d+)/(.+))&lt;/span&gt;
    &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;set&lt;/span&gt; &lt;span class="err"&gt;$id&lt;/span&gt; &lt;span class="err"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;set&lt;/span&gt; &lt;span class="err"&gt;$params&lt;/span&gt; &lt;span class="err"&gt;$2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;proxy_pass&lt;/span&gt; &lt;span class="nt"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="nt"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;com&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;5543&lt;/span&gt;&lt;span class="o"&gt;/$&lt;/span&gt;&lt;span class="nt"&gt;params&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以先rewrite一下，然后再代理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;^~&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;rewrite&lt;/span&gt; &lt;span class="err"&gt;/test/(\d+)/(.+)&lt;/span&gt; &lt;span class="err"&gt;/$2?$args&lt;/span&gt; &lt;span class="err"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5543&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;~*&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;+)/(.+)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5543&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意上面最后的&lt;code&gt;?$args&lt;/code&gt;，表明把原始url最后的get参数也给代理到后台&lt;br&gt;
如果在proxy_pass中使用了变量（不管是主机名变量$1或后面的$2变量），则必须得加这段代码&lt;br&gt;
但如果pass_proxy后没用任何变量，则不需要加，它默认会把所有的url都给代理到后台，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;~*&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;+)/(.+)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5543&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;url的/问题&lt;/h2&gt;
&lt;p&gt;在nginx中配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走。&lt;/p&gt;
&lt;p&gt;下面四种情况分别用http://192.168.1.12/proxy/test.html 进行访问。&lt;br&gt;
* 第一种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会被代理到http://192.168.1.12:81/test.html 这个url&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二种(相对于第一种，最后少一个 /)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会被代理到http://192.168.1.12:81/proxy/test.html 这个url&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三种：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会被代理到http://192.168.1.12:81/app/test.html 这个url。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第四种情况(相对于第三种，最后少一个 / )：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会被代理到http://192.168.1.12:81/apptest.html 这个url&lt;/p&gt;
&lt;p&gt;从上面结果可以看出，准确说分两种情况：
1. http://192.168.1.12:81 (上面的第二种) 这种
2. http://127.0.0.1:81/.... （上面的第1，3，4种） 这种&lt;/p&gt;</content><category term="nginx"></category><category term="reverse"></category><category term="proxy"></category><category term="反向代理"></category></entry><entry><title>python字典和列表赋值的坑</title><link href="https://yull.in/python-dict-and-list-copy.html" rel="alternate"></link><published>2018-12-18T14:40:00+08:00</published><updated>2018-12-18T14:40:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-12-18:/python-dict-and-list-copy.html</id><summary type="html">&lt;p&gt;今天在实际脚本中遇到了一个python的变量赋值的坑，将字典从一个变量a赋值给另外一个变量b之后，修改了原始变量a的值，本意是保持b变量为原始值不动，结果修改a之后发现b的值也随着改变了，经过一番查询以及自己的测试之后，确认原来python中的list和dict数据类型采用的是浅拷贝。  &lt;/p&gt;
&lt;p&gt;列表的具体测试如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a = [&amp;#39;1&amp;#39;]
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; a.append(&amp;#39;2&amp;#39;)
&amp;gt;&amp;gt;&amp;gt; a
[&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;]
&amp;gt;&amp;gt;&amp;gt; b
[&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到当改变a的值时，b的值也跟着一起改变了。
再看字典的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; ar = {&amp;#39;x&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;y&amp;#39;:&amp;#39;2&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; br = ar
&amp;gt;&amp;gt;&amp;gt; br
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;1&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; ar[&amp;#39;x&amp;#39;] = &amp;#39;3&amp;#39;
&amp;gt;&amp;gt;&amp;gt; br
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;3&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; ar
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;3&amp;#39;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实还可以有更简单的验证方式 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天在实际脚本中遇到了一个python的变量赋值的坑，将字典从一个变量a赋值给另外一个变量b之后，修改了原始变量a的值，本意是保持b变量为原始值不动，结果修改a之后发现b的值也随着改变了，经过一番查询以及自己的测试之后，确认原来python中的list和dict数据类型采用的是浅拷贝。  &lt;/p&gt;
&lt;p&gt;列表的具体测试如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a = [&amp;#39;1&amp;#39;]
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; a.append(&amp;#39;2&amp;#39;)
&amp;gt;&amp;gt;&amp;gt; a
[&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;]
&amp;gt;&amp;gt;&amp;gt; b
[&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到当改变a的值时，b的值也跟着一起改变了。
再看字典的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; ar = {&amp;#39;x&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;y&amp;#39;:&amp;#39;2&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; br = ar
&amp;gt;&amp;gt;&amp;gt; br
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;1&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; ar[&amp;#39;x&amp;#39;] = &amp;#39;3&amp;#39;
&amp;gt;&amp;gt;&amp;gt; br
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;3&amp;#39;}
&amp;gt;&amp;gt;&amp;gt; ar
{&amp;#39;y&amp;#39;: &amp;#39;2&amp;#39;, &amp;#39;x&amp;#39;: &amp;#39;3&amp;#39;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实还可以有更简单的验证方式，即查看变量的id值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; id(a)
139930012177976
&amp;gt;&amp;gt;&amp;gt; id(b)
139930012177976
&amp;gt;&amp;gt;&amp;gt; id(ar)
139930012303440
&amp;gt;&amp;gt;&amp;gt; id(br)
139930012303440
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到他们虽然变量名不一样，但实际指向的内存地址是同一个（称之为浅拷贝），所以修改任意一个的值，意味着变量值都改变了。  &lt;/p&gt;
&lt;p&gt;如果想要实现深拷贝，即开头提到的原本需求，实现深拷贝，则需要用到deepcopy功能，具体使用如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;copy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;deepcopy&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;deepcopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;139930012252784&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;139930012253000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上面的测试可以看到，a和b分别指向了两个不同的内存地址，这样修改a的值并不会影响b的值了。&lt;/p&gt;</content><category term="python"></category><category term="dict"></category><category term="list"></category></entry><entry><title>curl usage note</title><link href="https://yull.in/curl-usage-note.html" rel="alternate"></link><published>2018-11-02T11:08:00+08:00</published><updated>2018-11-02T11:08:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-11-02:/curl-usage-note.html</id><summary type="html">&lt;p&gt;CURL可以详细打印出请求过程每一步所消耗的时间，对于我们日常的排查故障非常有用。&lt;br&gt;
下面说一下具体的使用方法：  &lt;/p&gt;
&lt;h3&gt;1.建立一个命令格式文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\n 
　　　　　　　time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;br&gt;
time_namelookup：DNS解析域名时间，把域名---&amp;gt;ip的时间&lt;br&gt;
time_connect：TCP连接的时间，三次握手的时间&lt;br&gt;
time_appconnect：SSL|SSH等上层连接建立的时间&lt;br&gt;
time_pretransfer：从请求开始到到响应开始传输的时间&lt;br&gt;
time_redirect：从开始到最后一个请求事务的时间&lt;br&gt;
time_starttransfer：从请求开始到第一个字节将要传输的时间&lt;br&gt;
time_total：总时间&lt;/p&gt;
&lt;h3&gt;2.命令使用方法 …&lt;/h3&gt;</summary><content type="html">&lt;p&gt;CURL可以详细打印出请求过程每一步所消耗的时间，对于我们日常的排查故障非常有用。&lt;br&gt;
下面说一下具体的使用方法：  &lt;/p&gt;
&lt;h3&gt;1.建立一个命令格式文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\n 
　　　　　　　time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;br&gt;
time_namelookup：DNS解析域名时间，把域名---&amp;gt;ip的时间&lt;br&gt;
time_connect：TCP连接的时间，三次握手的时间&lt;br&gt;
time_appconnect：SSL|SSH等上层连接建立的时间&lt;br&gt;
time_pretransfer：从请求开始到到响应开始传输的时间&lt;br&gt;
time_redirect：从开始到最后一个请求事务的时间&lt;br&gt;
time_starttransfer：从请求开始到第一个字节将要传输的时间&lt;br&gt;
time_total：总时间&lt;/p&gt;
&lt;h3&gt;2.命令使用方法&lt;/h3&gt;
&lt;p&gt;curl -w "@curl" -o /dev/null -s -d "username=aaa&amp;amp;password=bbb" https://xxx.xxx.com/webapp/xxx/login&lt;/p&gt;
&lt;p&gt;-w：从文件中读取信息打印格式&lt;/p&gt;
&lt;p&gt;-o：输出的全部信息&lt;/p&gt;
&lt;p&gt;-s：不打印进度条&lt;/p&gt;
&lt;p&gt;-d：参数&lt;/p&gt;
&lt;h3&gt;3.简单的方式&lt;/h3&gt;
&lt;p&gt;curl -o /dev/null -s -w '%{time_connect}:%{time_starttransfer}:%{time_total}\n' 'http://www.baidu.com'&lt;/p&gt;
&lt;p&gt;忽略ssl认证  并输出结果&lt;/p&gt;
&lt;p&gt;curl -k -XPOST -w '\n%{time_connect}:%{time_starttransfer}:%{time_total}\n' www.baidu.com&lt;/p&gt;
&lt;h3&gt;4.当Content-Type:application/json，requestBody:{id: 93, status: 2}&lt;/h3&gt;
&lt;p&gt;curl -w "@curl" -H "Content-Type:application/json" -X PUT --data '{id: 93, status: 2}' http:/xxxxxxxxxxx/changeStatus&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;curl 命令提供了 -w 参数，这个参数在 manpage 是这样解释的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-w, --write-out &amp;lt;format&amp;gt;
              Make curl display information on stdout after a completed transfer. The format is a string that may contain plain text mixed with any number of variables. The  format
              can  be  specified  as  a literal &amp;quot;string&amp;quot;, or you can have curl read the format from a file with &amp;quot;@filename&amp;quot; and to tell curl to read the format from stdin you write
              &amp;quot;@-&amp;quot;.

              The variables present in the output format will be substituted by the value or text that curl thinks fit, as described below. All variables are specified  as  %{vari‐
              able_name} and to output a normal % you just write them as %%. You can output a newline by using \n, a carriage return with \r and a tab space with \t.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它能够按照指定的格式打印某些信息，里面可以使用某些特定的变量，而且支持 \n 、 \t 和 \r 转义字符。提供的变量很多，比如 status_code 、 local_port 、 size_download 等等，这篇文章我们只关注和请求时间有关的变量（以 time_ 开头的变量）。&lt;/p&gt;
&lt;p&gt;先往文本文件 curl-format.txt 写入下面的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;➜  ~ cat curl-format.txt
    time_namelookup:  %{time_namelookup}\n
       time_connect:  %{time_connect}\n
    time_appconnect:  %{time_appconnect}\n
      time_redirect:  %{time_redirect}\n
   time_pretransfer:  %{time_pretransfer}\n
 time_starttransfer:  %{time_starttransfer}\n
                    ----------\n
         time_total:  %{time_total}\n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么这些变量都是什么意思呢？我解释一下：&lt;/p&gt;
&lt;p&gt;time_namelookup ：DNS 域名解析的时候，就是把 https://zhihu.com 转换成 ip 地址的过程
time_connect ：TCP 连接建立的时间，就是三次握手的时间
time_appconnect ：SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间
time_redirect ：从开始到最后一个请求事务的时间
time_pretransfer ：从请求开始到响应开始传输的时间
time_starttransfer ：从请求开始到第一个字节将要传输的时间
time_total ：这次请求花费的全部时间
我们先看看一个简单的请求，没有重定向，也没有 SSL 协议的时间：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;➜  ~ curl -w &amp;quot;@curl-format.txt&amp;quot; -o /dev/null -s -L &amp;quot;http://cizixs.com&amp;quot;
    time_namelookup:  0.012
       time_connect:  0.227
    time_appconnect:  0.000
      time_redirect:  0.000
   time_pretransfer:  0.227
 time_starttransfer:  0.443
                    ----------
         time_total:  0.867
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这次请求各个步骤的时间都打印出来了，每个数字的单位都是秒（seconds），这样可以分析哪一步比较耗时，方便定位问题。这个命令各个参数的意义：&lt;/p&gt;
&lt;p&gt;-w ：从文件中读取要打印信息的格式
-o /dev/null ：把响应的内容丢弃，因为我们这里并不关心它，只关心请求的耗时情况
-s ：不要打印进度条
从这个输出，我们可以算出各个步骤的时间：&lt;/p&gt;
&lt;p&gt;DNS 查询：12ms
TCP 连接时间：pretransfter(227) - namelookup(12) = 215ms
服务器处理时间：starttransfter(443) - pretransfer(227) = 216ms
内容传输时间：total(867) - starttransfer(443) = 424ms
来个比较复杂的，访问某度首页，带有中间有重定向和 SSL 协议：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;➜  ~ curl -w &amp;quot;@curl-format.txt&amp;quot; -o /dev/null -s -L &amp;quot;https://baidu.com&amp;quot;
    time_namelookup:  0.012
       time_connect:  0.018
    time_appconnect:  0.328
      time_redirect:  0.356
   time_pretransfer:  0.018
 time_starttransfer:  0.027
                    ----------
         time_total:  0.384
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到 time_appconnect 和 time_redirect 都不是 0 了，其中 SSL 协议处理时间为 328-18=310ms 。而且 pretransfer 和 starttransfer 的时间都缩短了，这是重定向之后请求的时间。&lt;/p&gt;</content><category term="curl"></category><category term="usage"></category><category term="get"></category><category term="post"></category></entry><entry><title>configure elasticsearch logstash kibana</title><link href="https://yull.in/config-elasticsearch-logstash-kibana.html" rel="alternate"></link><published>2018-10-26T11:20:00+08:00</published><updated>2018-10-26T11:20:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-10-26:/config-elasticsearch-logstash-kibana.html</id><summary type="html">&lt;p&gt;本文主要记录ELK的测试环境的搭建过程   &lt;/p&gt;
&lt;h3&gt;1.环境以及架构&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Jumper&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th align="center"&gt;IP地址&lt;/th&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.30&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8030&lt;/td&gt;
&lt;td&gt;Kibana&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.31&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8031&lt;/td&gt;
&lt;td&gt;Logstash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.32&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8032&lt;/td&gt;
&lt;td&gt;ElasticSearch&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本次的所有环境均是基于CENTOS7系统进行搭建。&lt;br&gt;
首先是准备环境，安装JAVA运行环境JDK，需要先上传下载好的JDK,这里我下载的是rpm安装包。
由于安全原因，不能直接上传，只能先上传到d1000.intsig.net的FTP服务器上，然后通过wget命令进行下载。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://10.2 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本文主要记录ELK的测试环境的搭建过程   &lt;/p&gt;
&lt;h3&gt;1.环境以及架构&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Jumper&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th align="center"&gt;IP地址&lt;/th&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.30&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8030&lt;/td&gt;
&lt;td&gt;Kibana&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.31&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8031&lt;/td&gt;
&lt;td&gt;Logstash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d1000&lt;/td&gt;
&lt;td&gt;CENTOS 7&lt;/td&gt;
&lt;td align="center"&gt;10.2.8.32&lt;/td&gt;
&lt;td&gt;centosT-AutomELK-8032&lt;/td&gt;
&lt;td&gt;ElasticSearch&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本次的所有环境均是基于CENTOS7系统进行搭建。&lt;br&gt;
首先是准备环境，安装JAVA运行环境JDK，需要先上传下载好的JDK,这里我下载的是rpm安装包。
由于安全原因，不能直接上传，只能先上传到d1000.intsig.net的FTP服务器上，然后通过wget命令进行下载。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://10.2.4.11/bin_deng/packagename.rpm  
rpm -ivh packagename.rpm
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2.安装配置Elasticsearch&lt;/h3&gt;
&lt;p&gt;首先需要下载最新版本：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.1.tar.gz  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载后解压至&lt;code&gt;/usr/local/&lt;/code&gt;目录下，解压后的路径即为&lt;code&gt;/usr/local/elasticsearch-6.3.1/&lt;/code&gt;，做一个软链接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ln -s /usr/local/elasticsearch-6.3.1 /usr/local/elasticsearch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改配置文件&lt;code&gt;/usr/local/elasticsearch/config/elasticsearch.yml&lt;/code&gt;，需要修改以下几项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;network.host: 10.2.8.32  #设置为本机外网可访问的IP
http.port: 9200          #设置监听端口为9200  
cluster.name: my-es      #设置集群名字
node.name: node-1        #设置节点名字
path.data: /data/es_data #设置数据文件存储目录
path.logs: /data/es_logs #设置日志文件目录
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改完成后，启动elasticsearch  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/local/elasticsearch/bin/elasticsearch  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;启动直接就报错了，报错信息如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.nio.file.AccessDeniedException: /usr/local/elasticsearch/config/jvm.options
        at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:90)
        at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
        at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
        at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
        at java.base/java.nio.file.Files.newByteChannel(Files.java:369)
        at java.base/java.nio.file.Files.newByteChannel(Files.java:415)
        at java.base/java.nio.file.spi.FileSystemProvider.newInputStream(FileSystemProvider.java:384)
        at java.base/java.nio.file.Files.newInputStream(Files.java:154)
        at org.elasticsearch.tools.launchers.JvmOptionsParser.main(JvmOptionsParser.java:58)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过查询是由于执行该命令的用户没有运行jvm的权限导致该报错，所以我们新建一个elk用户:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo useradd elk  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后修改目录归属：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo chown -R elk.elk /usr/local/elasticsearch* 
sudo chown -R elk.elk /data/es_*               #修改/data/es_data和/data/es_log目录的权限 
sudo su
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在root用户下运行elasticsearch也会报错&lt;code&gt;can not run elasticsearch as root&lt;/code&gt;，所以我们需要切换到elk用户下面再启动elasticsearch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;su elk
/usr/local/elasticsearch/bin/elasticsearch -d  #-d参数是后台运行
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改之后仍然还是有报错，报错如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ERROR: [1] bootstrap checks failed
[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要在/etc/sysctl.conf中修改配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vm.max_map_count=262144
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者在命令行中执行&lt;code&gt;sysctl -w vm.max_map_count=262144&lt;/code&gt;&lt;br&gt;
如此折腾一番之后，可以正常运行elasticsearch了。&lt;/p&gt;
&lt;h3&gt;3.安装配置Logstash&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;需要注意的一点是新版的logstash-6.3.2不支持最新版的jdk-10.0.2，需要降为上一个稳定版jdk-8u181。否则会报错&lt;code&gt;Unrecognized VM option 'UseParNewGC'&lt;/code&gt;参考链接https://github.com/elastic/logstash/issues/9345&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载最新版本的Logstash:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo wget https://artifacts.elastic.co/downloads/logstash/logstash-6.3.2.tar.gz
sudo tar xzf logstash-6.3.2.tar.gz -C /usr/local/
sudo ln -s logstash-6.3.2 logstash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;/esr/local/logstash/config&lt;/code&gt;目录下面新建log.conf配置文件，并添加以下修改内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;input {
  stdin {
    type =&amp;gt; &amp;quot;syslog&amp;quot;
  }
  #file {
  #  type =&amp;gt; &amp;quot;hadoop-yarnlog&amp;quot;
  #  path =&amp;gt; &amp;quot;/usr/local/hadoop/logs/yarn-hadoop-resourcemanager-m000.log&amp;quot;
  #}
}

output {
  elasticsearch {
    hosts =&amp;gt; &amp;quot;10.2.8.32:9200&amp;quot;
    index =&amp;gt; &amp;quot;logstash-%{type}-%{+YYYY.MM.dd}&amp;quot;
    template_overwrite =&amp;gt; true
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于logstash配置文件的解释可以参考 &lt;a href="https://blog.csdn.net/king7950/article/details/61196447"&gt;csdn blog&lt;/a&gt; 的说明 &lt;/p&gt;
&lt;p&gt;关于logstash的启动命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /usr/local/logstash/bin/logstash -f /usr/local/logstash/config/log.conf &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的方式启动主要是为了防止其产生不必要的输出，占用磁盘存储。&lt;/p&gt;
&lt;h3&gt;4.安装配置Kibana&lt;/h3&gt;
&lt;p&gt;到官网进行下载最新版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd /usr/local/src/
sudo wget https://artifacts.elastic.co/downloads/kibana/kibana-6.3.2-linux-x86_64.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后解压缩到&lt;code&gt;/usr/local/&lt;/code&gt;目录下面&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo tar xzf kibana-6.3.2-linux-x86_64.tar.gz -C /usr/local/
cd /usr/local/
sudo ln -s kibana-6.3.2-linux-x86_64 kibana
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改配置文件&lt;code&gt;/usr/local/kibana/config/kibana.yml&lt;/code&gt;中的以下参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;server.port: 5601                           #kibana的监听端口
server.host: &amp;quot;10.2.8.30&amp;quot;                    #kibana的绑定IP
elasticsearch.url: &amp;quot;http://10.2.8.32:9200&amp;quot;  #kibana的后端数据查询链接
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改完成后启动kibana到后台&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /usr/local/kibana/bin/kibana &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;</content><category term="elk"></category><category term="elasticsearch"></category><category term="logstash"></category><category term="kibana"></category><category term="ingest node"></category></entry><entry><title>win10十月更新坑用户</title><link href="https://yull.in/microsoft-win10-oct-update.html" rel="alternate"></link><published>2018-10-09T18:08:00+08:00</published><updated>2018-10-09T18:08:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-10-09:/microsoft-win10-oct-update.html</id><summary type="html">&lt;p&gt;昨日微软撤回了Windows 10的2018年十月更新，让这次发布已经接近成为了一个笑话，不过更大的笑话还在后面：又有用户报告了十月更新当中的重大问题：本次操作系统版本更新曾被多次提供给相同的PC，尽管其中一些实际安装成功，微软还是非常客气地无事献殷勤：让他们再安装一遍。&lt;/p&gt;
&lt;p&gt;换句话说，一些用户被提示安装2018年10月更新，即使在同一天早些时候，他们做了同样的事情。&lt;/p&gt;
&lt;p&gt;虽然这是一个非常尴尬的错误，但万幸的是，第二次安装2018年10月更新，系统重启和所有内容，都没有更改受影响系统上的文件。&lt;/p&gt;
&lt;p&gt;reddit的一个讨论主题证实了几个用户遇到了这个问题，虽然目前还不知道这个bug究竟有多广泛。&lt;/p&gt;
&lt;p&gt;但是，随着Windows 10 10月2018 Update的撤下，此问题不再发生，用户将无法再看到通过Windows Update提供的新版本。&lt;/p&gt;
&lt;p&gt;Windows 10 10月2018更新，也称为版本1809，于10月2日宣布，同一天，微软开始允许用户通过手动检查后通过Windows Update下载。&lt;/p&gt;
&lt;p&gt;然而，到目前为止，新操作系统功能更新带来了众多问题，最糟糕的问题导致在升级期间完全删除用户文件，虽然目前尚不清楚有多少台PC出现此问题，但微软决定完全撤销2018年10月的更新。&lt;/p&gt;
&lt;p&gt;目前还不知道微软什么时候想恢复推出，但随着10月的周二补丁日即将到来，预计下周会有更多这方面的新闻。&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日微软撤回了Windows 10的2018年十月更新，让这次发布已经接近成为了一个笑话，不过更大的笑话还在后面：又有用户报告了十月更新当中的重大问题：本次操作系统版本更新曾被多次提供给相同的PC，尽管其中一些实际安装成功，微软还是非常客气地无事献殷勤：让他们再安装一遍。&lt;/p&gt;
&lt;p&gt;换句话说，一些用户被提示安装2018年10月更新，即使在同一天早些时候，他们做了同样的事情。&lt;/p&gt;
&lt;p&gt;虽然这是一个非常尴尬的错误，但万幸的是，第二次安装2018年10月更新，系统重启和所有内容，都没有更改受影响系统上的文件。&lt;/p&gt;
&lt;p&gt;reddit的一个讨论主题证实了几个用户遇到了这个问题，虽然目前还不知道这个bug究竟有多广泛。&lt;/p&gt;
&lt;p&gt;但是，随着Windows 10 10月2018 Update的撤下，此问题不再发生，用户将无法再看到通过Windows Update提供的新版本。&lt;/p&gt;
&lt;p&gt;Windows 10 10月2018更新，也称为版本1809，于10月2日宣布，同一天，微软开始允许用户通过手动检查后通过Windows Update下载。&lt;/p&gt;
&lt;p&gt;然而，到目前为止，新操作系统功能更新带来了众多问题，最糟糕的问题导致在升级期间完全删除用户文件，虽然目前尚不清楚有多少台PC出现此问题，但微软决定完全撤销2018年10月的更新。&lt;/p&gt;
&lt;p&gt;目前还不知道微软什么时候想恢复推出，但随着10月的周二补丁日即将到来，预计下周会有更多这方面的新闻。&lt;/p&gt;</content><category term="win10"></category><category term="microsoft"></category><category term="update"></category><category term="201810"></category></entry><entry><title>install and config openresty</title><link href="https://yull.in/install-and-config-openresty.html" rel="alternate"></link><published>2018-08-30T10:38:00+08:00</published><updated>2018-08-30T10:38:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-08-30:/install-and-config-openresty.html</id><summary type="html">&lt;h3&gt;安装配置openresty&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载源码  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd /usr/local/src
wget https://openresty.org/download/openresty-1.13.6.2.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;解压后编译安装  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install pcre-devel openssl-devel gcc curl  #需要事先准备好需要的依赖包
tar xzf openresty-1.13.6.2.tar.gz
cd openresty-1.13.6.2
 ./configure --prefix=/usr/local/openresty --with-luajit --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-debug
gmake -j2 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;安装配置openresty&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载源码  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd /usr/local/src
wget https://openresty.org/download/openresty-1.13.6.2.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;解压后编译安装  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install pcre-devel openssl-devel gcc curl  #需要事先准备好需要的依赖包
tar xzf openresty-1.13.6.2.tar.gz
cd openresty-1.13.6.2
 ./configure --prefix=/usr/local/openresty --with-luajit --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-debug
gmake -j2   ##由于是双核CPU，所以编译时添加-j2的参数
gmake install
&lt;/pre&gt;&lt;/div&gt;</content><category term="openresty"></category></entry><entry><title>configure elasticsearch ingest node</title><link href="https://yull.in/config-elasticsearch-ingest-node.html" rel="alternate"></link><published>2018-08-20T18:08:00+08:00</published><updated>2018-08-20T18:08:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-08-20:/config-elasticsearch-ingest-node.html</id><summary type="html">&lt;p&gt;在elastic 5.*版本开始支持ingest node功能，他可以在一定程度上替代Logstash的处理功能，只要是熟悉了其支持的格式之后，配置还是比较简单的。  &lt;/p&gt;
&lt;h3&gt;1.测试可以用如下命令&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;curl  -v -H 'Content-Type: application/json' -X POST 'http://10.2.4.34:9200/_ingest/pipeline/_simulate' -d@filebeat.test.json&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;filebeat.test.json的内容如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;pipeline&amp;quot; : {
    &amp;quot;description&amp;quot; : &amp;quot;nginx access log&amp;quot;,
    &amp;quot;processors&amp;quot;: [
      {
        &amp;quot;grok&amp;quot;: {
          &amp;quot;field&amp;quot;: &amp;quot;message&amp;quot;,
          &amp;quot;patterns&amp;quot;: [&amp;quot;%{IP:client_ip} %{TIMESTAMP_ISO8601:iso_time} %{BASE10NUM:timestamp} %{BASE10NUM …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;在elastic 5.*版本开始支持ingest node功能，他可以在一定程度上替代Logstash的处理功能，只要是熟悉了其支持的格式之后，配置还是比较简单的。  &lt;/p&gt;
&lt;h3&gt;1.测试可以用如下命令&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;curl  -v -H 'Content-Type: application/json' -X POST 'http://10.2.4.34:9200/_ingest/pipeline/_simulate' -d@filebeat.test.json&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;filebeat.test.json的内容如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;pipeline&amp;quot; : {
    &amp;quot;description&amp;quot; : &amp;quot;nginx access log&amp;quot;,
    &amp;quot;processors&amp;quot;: [
      {
        &amp;quot;grok&amp;quot;: {
          &amp;quot;field&amp;quot;: &amp;quot;message&amp;quot;,
          &amp;quot;patterns&amp;quot;: [&amp;quot;%{IP:client_ip} %{TIMESTAMP_ISO8601:iso_time} %{BASE10NUM:timestamp} %{BASE10NUM:request_time} %{BASE10NUM:request_length} %{INT:connection_id} %{INT:connection_requests} %{PATH:uri} \&amp;quot;%{WORD:request_method} %
{NOTSPACE:request} HTTP/%{NUMBER:httpversion}\&amp;quot; %{NUMBER:response_status} (?:%{NUMBER:bytes}|-) (?:%{NUMBER:error_code}|-) \&amp;quot;(?:%{WORD:error_msg}|-)\&amp;quot; %{QS:referrer} %{QS:agent} \&amp;quot;%{DATA:x_forwarded_for}\&amp;quot; \&amp;quot;%{DATA:x_is_ip}\&amp;quot; %{HOSTN
AME:server_host} %{URIHOST:upstream_addr} %{BASE10NUM:upstream_response_time} %{NUMBER:upstream_status} \&amp;quot;(?:%{IP:x_is_client_ip}|-)\&amp;quot;&amp;quot;],
          &amp;quot;ignore_missing&amp;quot;: true
        }
      }
    ]
  },
  &amp;quot;docs&amp;quot; : [
    { &amp;quot;_source&amp;quot;: {
        &amp;quot;message&amp;quot;: &amp;quot;101.95.128.162 2018-08-09T19:26:41+08:00 1533814001.040 0.061 407 27500839 1 /wp-includes/js/jquery/jquery.js \&amp;quot;GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.1\&amp;quot; 200 97184 - \&amp;quot;-\&amp;quot; \&amp;quot;http://blog.zdao.com/\
&amp;quot; \&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36\&amp;quot; \&amp;quot;-\&amp;quot; \&amp;quot;-\&amp;quot; blog.zdao.com 106.75.223.130:80 0.061 200 \&amp;quot;101.95.128.162\&amp;quot;&amp;quot; 
      }
    }
  ]
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置文件filebeat.yml如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /data/front/webcc_online/*/*/*/10.2.0.247/5032/*.log
  fields:
    type: &amp;quot;access-log&amp;quot;

filebeat.config.modules:
  path: &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/modules.d/*.yml
  reload.enabled: false

setup.template.settings:
  index.number_of_shards: 3

setup.template.name: &amp;quot;ignore-this&amp;quot;
setup.template.pattern: &amp;quot;ignore-this&amp;quot;

setup.kibana:
  host: &amp;quot;localhost:5601&amp;quot;

output.elasticsearch:
  hosts: [&amp;quot;10.2.4.34:9200&amp;quot;]
  indices:
    - index: &amp;quot;filebeat-nginx-access-%{+yyy.MM.dd}&amp;quot;
      when.equals:
        fields.type: &amp;quot;access-log&amp;quot;
  pipelines:
    - pipeline: &amp;quot;pipeline-nginx-access&amp;quot;
      when.equals:
        fields.type: &amp;quot;access-log&amp;quot;
&lt;/pre&gt;&lt;/div&gt;</content><category term="elk"></category><category term="elasticsearch"></category><category term="logstash"></category><category term="kibana"></category><category term="ingest node"></category></entry><entry><title>install php extension imagick</title><link href="https://yull.in/install-php-extension-imagick.html" rel="alternate"></link><published>2018-08-09T16:06:00+08:00</published><updated>2018-08-09T16:06:00+08:00</updated><author><name>Yullin</name></author><id>tag:yull.in,2018-08-09:/install-php-extension-imagick.html</id><summary type="html">&lt;p&gt;linux下配置imagick的步骤为(以centOS为例):&lt;/p&gt;
&lt;h3&gt;1. 安装ImageMagick&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install ImageMagick-devel
/usr/local/imagemagick/bin/convert -sample 25%x25% a.jpg b.jpg #测试语句
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2.  安装php的imagick扩展模块 (http://pecl.php.net/package/imagick)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://pecl.php.net/get/imagick-3.1.0RC2.tgz
tar -zxvf imagick-3.1.0RC2.tgz
/usr/local/php/bin/phpize                   #在项目目录下运行phpize …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;linux下配置imagick的步骤为(以centOS为例):&lt;/p&gt;
&lt;h3&gt;1. 安装ImageMagick&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install ImageMagick-devel
/usr/local/imagemagick/bin/convert -sample 25%x25% a.jpg b.jpg #测试语句
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2.  安装php的imagick扩展模块 (http://pecl.php.net/package/imagick)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://pecl.php.net/get/imagick-3.1.0RC2.tgz
tar -zxvf imagick-3.1.0RC2.tgz
/usr/local/php/bin/phpize                   #在项目目录下运行phpize, phpize为项目生成合乎php使用的configure文件
./configure --with-php-config=/usr/local/php/bin/php-config --with-imagick=/usr/local/imagemagick   #php-config:获取php配置信息
make
make install
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4. 配置php.ini&lt;/h3&gt;
&lt;p&gt;在php.ini中加入下面这句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;extension=imagick.so&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="php"></category><category term="imagick"></category><category term="php extension"></category></entry></feed>